# STUDIO Technical Documentation

## System Architecture

### Overview
STUDIO is a Flask-based voice and text assistant with modular architecture supporting multiple AI backends, real-time speech processing, and intelligent response generation.

### Core Components

#### 1. Flask Application Server (app.py)
```python
# Main endpoints
POST /asr     # Audio processing and voice recognition
POST /text    # Text input with optional TTS
POST /test    # Health check and basic functionality
```

**Request Flow:**
- Audio files processed via AssemblyAI API
- Text responses generated by assistant logic
- Optional TTS conversion via Murf AI
- JSON responses with metadata

#### 2. Assistant Logic Modules

**simple_assistant.py** (Primary)
- Pattern-based response generation
- Direct API integrations (wttr.in, NewsAPI)
- Fast local processing for common queries
- Navigation object generation for auto-redirect

**assistant_logic.py** (Enhanced)
- OpenAI GPT-4o-mini with function calling
- Dynamic tool selection and execution
- Response caching with LRU algorithm
- Advanced conversation handling

**offline_assistant.py** (Fallback)
- Network-independent operation
- Local pattern matching only
- Basic responses without API calls

#### 3. API Integration Layer

**Speech Recognition (asr_api.py)**
```python
def transcribe_audio(audio_file_path):
    # AssemblyAI integration
    # Returns transcribed text or error
```

**Text-to-Speech (murf_api.py)**
```python
def generate_speech(text, voice_id="en-US-davis"):
    # Murf AI integration
    # Returns audio file path or None
```

### Frontend Architecture

#### HTML Structure (index.html)
- Dual-mode interface: voice + text input
- Real-time audio visualization
- Response display with formatting
- TTS controls and settings

#### JavaScript Logic (dual_script.js)
```javascript
// Core functions
startRecording()     // MediaRecorder API
stopRecording()      // Audio processing
submitText()         // Form handling
handleResponse()     // Navigation redirect processing
```

#### CSS Styling (dual_style.css)
- Reactor-themed design system
- Responsive grid layout
- Animation states and transitions
- Accessibility considerations

## Data Models

### Request/Response Formats

**ASR Request:**
```json
{
  "audio": "base64_encoded_audio_data"
}
```

**Text Request:**
```json
{
  "text": "user_input_text",
  "tts": true/false
}
```

**Standard Response:**
```json
{
  "response": "assistant_reply_text",
  "audio_file": "path/to/audio.mp3" // optional
}
```

**Navigation Response:**
```json
{
  "type": "navigation",
  "message": "Opening Google Maps for navigation to destination...",
  "redirect_url": "https://www.google.com/maps/search/destination",
  "destination": "destination_name"
}
```

### Database Schema
Currently stateless - no persistent storage required.
Future considerations: user preferences, conversation history.

## API Integrations

### 1. AssemblyAI (Speech Recognition)
```python
# Configuration
ASSEMBLYAI_API_KEY = os.getenv('ASSEMBLYAI_API_KEY')
upload_url = "https://api.assemblyai.com/v2/upload"
transcript_url = "https://api.assemblyai.com/v2/transcript"

# Usage
response = requests.post(upload_url, files={'file': audio_file})
transcript_response = requests.post(transcript_url, json={"audio_url": upload_response['upload_url']})
```

### 2. Murf AI (Text-to-Speech)
```python
# Configuration
MURF_API_KEY = os.getenv('MURF_API_KEY')
api_url = "https://api.murf.ai/v1/speech/generate"

# Usage
response = requests.post(api_url, json={
    "voiceId": voice_id,
    "text": text,
    "format": "mp3"
})
```

### 3. OpenAI (AI Chat)
```python
# Function calling setup
tools = [
    {
        "type": "function",
        "function": {
            "name": "get_weather",
            "description": "Get weather for a city",
            "parameters": {
                "type": "object",
                "properties": {"city": {"type": "string"}},
                "required": ["city"]
            }
        }
    }
]

# Usage with function calling
response = client.chat.completions.create(
    model="gpt-4o-mini",
    messages=messages,
    tools=tools,
    tool_choice="auto"
)
```

### 4. Weather Service (wttr.in)
```python
# Free service - no API key required
url = f"https://wttr.in/{city}?format=%C+%t+%h+%w"
# Format: Condition Temperature Humidity Wind
```

### 5. NewsAPI
```python
# Configuration
NEWS_API_KEY = os.getenv('NEWS_API_KEY')
url = f"https://newsapi.org/v2/everything?q={query}&apiKey={api_key}"

# Response processing
articles = response.json()['articles'][:5]  # Top 5 articles
```

## Performance Optimization

### Caching Strategy
```python
from functools import lru_cache

# Response caching
response_cache = {}
cache_key = text[:50]  # First 50 characters as key
cached_response = response_cache.get(cache_key)
```

### Async Processing
- Non-blocking API calls where possible
- Background audio processing
- Concurrent request handling

### Memory Management
- Temporary audio file cleanup
- Response cache size limits
- Efficient string processing

## Security Implementation

### API Key Management
```python
# Environment variables only
ASSEMBLYAI_API_KEY = os.getenv('ASSEMBLYAI_API_KEY')
MURF_API_KEY = os.getenv('MURF_API_KEY')
OPENAI_API_KEY = os.getenv('OPENAI_API_KEY')
NEWS_API_KEY = os.getenv('NEWS_API_KEY')
```

### Input Validation
```python
def validate_input(user_text):
    if not user_text or user_text.strip() == "":
        return False
    # Additional validation logic
    return True
```

### CORS Configuration
```python
from flask_cors import CORS
CORS(app)  # Enable cross-origin requests
```

## Error Handling

### API Error Management
```python
try:
    response = requests.get(url, timeout=10)
    if response.status_code == 200:
        return process_response(response)
    else:
        return fallback_response()
except requests.exceptions.RequestException as e:
    return error_response(str(e))
```

### Frontend Error Handling
```javascript
fetch('/asr', {
    method: 'POST',
    body: formData
})
.then(response => response.json())
.then(data => handleResponse(data))
.catch(error => {
    console.error('Error:', error);
    displayError('Connection failed. Please try again.');
});
```

## Testing Strategy

### Unit Tests
```python
# test_simple.py
def test_weather_response():
    response = get_weather("Mumbai")
    assert "Weather" in response
    assert "Mumbai" in response

def test_navigation_response():
    response = generate_reply("navigate to airport")
    assert response["type"] == "navigation"
    assert "redirect_url" in response
```

### Integration Tests
- API endpoint testing
- Audio processing pipeline
- Frontend-backend communication

### Performance Tests
- Response time benchmarks
- Concurrent user handling
- Memory usage monitoring

## Deployment Guide

### Local Development
```bash
# Setup
cd backend
pip install -r requirements.txt
cp .env.template .env  # Add API keys

# Run
python app.py

# Frontend
cd frontend
start index.html  # Windows
open index.html   # macOS
```

### Production Deployment
```bash
# Using Gunicorn
pip install gunicorn
gunicorn -w 4 -b 0.0.0.0:5000 app:app

# Environment variables
export ASSEMBLYAI_API_KEY="your_key"
export MURF_API_KEY="your_key"
export OPENAI_API_KEY="your_key"
export NEWS_API_KEY="your_key"
```

### Docker Deployment
```dockerfile
FROM python:3.9-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:5000", "app:app"]
```

## Monitoring and Logging

### Application Logging
```python
import logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Usage
logger.info(f"Processing request: {user_text}")
logger.error(f"API Error: {str(e)}")
```

### Performance Metrics
- Response time tracking
- API call success rates
- Error frequency monitoring
- User interaction patterns

## Future Enhancements

### Planned Features
1. **Wake Word Detection**: Always-listening mode
2. **Music Integration**: YouTube Music player
3. **Multi-language Support**: Translation capabilities
4. **User Profiles**: Personalized responses
5. **Conversation Memory**: Context retention

### Technical Improvements
1. **WebSocket Integration**: Real-time communication
2. **Database Layer**: Persistent storage
3. **Microservices Architecture**: Service separation
4. **Load Balancing**: Horizontal scaling
5. **Advanced Caching**: Redis integration

### Scalability Considerations
- Horizontal scaling with load balancers
- Database sharding for user data
- CDN integration for audio files
- Microservice decomposition
- Container orchestration (Kubernetes)

## Troubleshooting Guide

### Common Issues

**Server Won't Start**
```bash
# Check dependencies
pip list | grep flask
pip install -r requirements.txt

# Check port availability
netstat -an | grep 5000
```

**API Errors**
```bash
# Verify API keys
echo $ASSEMBLYAI_API_KEY
cat .env | grep API_KEY

# Test API connectivity
curl -H "Authorization: Bearer $ASSEMBLYAI_API_KEY" https://api.assemblyai.com/v2/transcript
```

**Audio Issues**
- Check microphone permissions in browser
- Verify audio format compatibility
- Test with different browsers
- Check system audio settings

**Navigation Not Working**
- Verify popup blocker settings
- Check browser console for errors
- Test with different browsers
- Ensure JavaScript is enabled

### Debug Mode
```python
# Enable Flask debug mode
app.run(debug=True, host='0.0.0.0', port=5000)

# Verbose logging
logging.basicConfig(level=logging.DEBUG)
```

### Performance Profiling
```python
import cProfile
import pstats

# Profile function execution
profiler = cProfile.Profile()
profiler.enable()
# ... code to profile ...
profiler.disable()
stats = pstats.Stats(profiler)
stats.sort_stats('cumulative').print_stats(10)
```